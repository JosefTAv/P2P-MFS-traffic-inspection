#include "Vclk_sync_pulse.h"             // Generated by Verilator
#include "verilated.h"
#include "verilated_fst_c.h"
#include <iostream>
#include <cassert>

#define DEFAULT_PERIOD (322)
#define STR(x) #x
#define TICK_PER_CLK (2) // nb ticks per clk period

int t = 0;

// utility
void eval_and_dump_wave(Vclk_sync_pulse* top, VerilatedFstC* tfp);

// test functions
void initial_reset(Vclk_sync_pulse* top, VerilatedFstC* tfp);
void test_master_mode(Vclk_sync_pulse* top, VerilatedFstC* tfp);
void test_axi_write(Vclk_sync_pulse* top, VerilatedFstC* tfp);
void test_slave_mode(Vclk_sync_pulse* top, VerilatedFstC* tfp);

int main(int argc, char **argv) {
    /*********************
		Verilator setup
	**********************/
    Verilated::commandArgs(argc, argv);
    Vclk_sync_pulse* top = new Vclk_sync_pulse;
    VerilatedFstC* tfp = new VerilatedFstC();

    Verilated::traceEverOn(true);       // Enable tracing
    top->trace(tfp, 99);                // Trace depth
    tfp->open("wave.fst");    // Output file

    /*********************
		Run tests
	**********************/
    initial_reset(top, tfp);
    test_master_mode(top, tfp);
    test_axi_write(top, tfp);
    test_slave_mode(top, tfp);

    tfp->close();
    delete tfp;
    delete top;
    return 0;
}

// system reset
void initial_reset(Vclk_sync_pulse* top, VerilatedFstC* tfp){
    top->axil_aresetn = 0;
    top->axil_aclk = 0; eval_and_dump_wave(top, tfp); t++;

    top->axil_aclk = 1; eval_and_dump_wave(top, tfp); t++;
    top->axil_aresetn = 1;
    std::cout << "t=(" << t << ")\t\t"  << "Finished initial reset" << std::endl;
}

// 
void test_master_mode(Vclk_sync_pulse* top, VerilatedFstC* tfp){
    
    int nb_periods = 4;
    int test_length = TICK_PER_CLK*(nb_periods*(DEFAULT_PERIOD)+1); // 2* to take into account the down tick 
    int end_t = t + test_length; 

    for (; t < end_t; t++) {
        top->axis_aclk = t % 2; eval_and_dump_wave(top, tfp);      
    }
    std::cout << "t=(" << t << ")\t"  << "Finished master mode test" << std::endl;

    if((int)(top->nb_sync_o) != nb_periods)
        std::cout << top->nb_sync_o << "!!!!! nb_sync_o should increment every " << DEFAULT_PERIOD << " ticks" << std::endl;
}

void test_axi_write(Vclk_sync_pulse* top, VerilatedFstC* tfp){
    // wait for axi slave
    while(!(top->s_axil_awready && top->s_axil_wready)){
        top->axis_aclk = t % 2; eval_and_dump_wave(top, tfp); t++;
    }

    // write 0 to reg_master_mode
    top->s_axil_awvalid = 1;
    top->s_axil_wvalid = 1;
    top->s_axil_awaddr = 0x0;
    top->s_axil_wdata = 0x0;
    for(int i=0; i < 4; i++){ // give two full cycles to allow for writing
        top->axil_aclk = t % 2; eval_and_dump_wave(top, tfp); t++;
    }
    top->s_axil_awvalid = 0;
    top->s_axil_wvalid = 0;
}

void test_slave_mode(Vclk_sync_pulse* top, VerilatedFstC* tfp){

    // check that it doesnt auto increment curr_tick or nb_sync
    int nb_periods = 2;
    int test_length = TICK_PER_CLK*(nb_periods*(DEFAULT_PERIOD)+1);
    int end_t = t + test_length; 

    for (; t < end_t; ) {
        top->axis_aclk = t % 2; eval_and_dump_wave(top, tfp); t++;
    }

    // check that it reacts to input from master pulse
    nb_periods = 2;
    test_length = TICK_PER_CLK*(nb_periods*(DEFAULT_PERIOD)+1);
    end_t = t + test_length; 
    int curr_nb_sync = (int)(top->nb_sync_o);

    for (; t < end_t; ) {
        top->sync_pulse_i = 0;

        if((t + 1) % (TICK_PER_CLK*DEFAULT_PERIOD) == 0 
                || (t) % (TICK_PER_CLK*DEFAULT_PERIOD) == 0) // hold high for full clock cycle every period
            top->sync_pulse_i = 1;

        top->axis_aclk = t % 2; eval_and_dump_wave(top, tfp); t++;
    }
    std::cout << "t=(" << t << ")\t"  << "Finished slave mode test" << std::endl;

    if((int)(top->nb_sync_o) != curr_nb_sync+nb_periods){
        std::cout << "!!!!! nb_sync_o should increment every " << DEFAULT_PERIOD << " ticks" << std::endl;
        std::cout << (int)(top->nb_sync_o) << " " << curr_nb_sync << " " << nb_periods << std::endl;
    }
}

void eval_and_dump_wave(Vclk_sync_pulse* top, VerilatedFstC* tfp){
    top->eval();
    tfp->dump(t);       // Dump to FST at time = t
}